# -*- coding: utf-8 -*-
"""HistogramEqualization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1d4l1n1cbgYRL5FECsv_FShJCbeB9hZW5
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2

#Reading Images:
img1=cv2.imread("image1.tif",0)
img2=cv2.imread("image2.tif",0)
img3=cv2.imread("image3.tif",0)
img4=cv2.imread("image4.png",0)

plt.subplot(2,2,1)
plt.imshow(img1,cmap="gray",vmin='0',vmax='255')
plt.subplot(2,2,2)
plt.imshow(img2,cmap="gray",vmin='0',vmax='255')
plt.subplot(2,2,3)
plt.imshow(img3,cmap="gray",vmin='0',vmax='255')
plt.subplot(2,2,4)
plt.imshow(img4,cmap="gray",vmin='0',vmax='255')

#Generalized code for finding the pixels and no of each pixel in a given image.
def Hist(img):
  r=np.arange(0,256, dtype=int)
  Img=np.copy(img)
  row,col=Img.shape
  max1 = np.max(Img)
  freq = np.zeros(len(r), dtype=int)
  for i in range(0,row):
    for j in range(0,col):
      temp=Img[i][j]
      freq[temp]+=1
  return (r,freq)

#Call histogram function for all the images and plot the histogram
images=np.array([img1,img2,img3,img4]) #Put all the images in one array
plt.figure(figsize= (20,3))
for i in range(len(images)):
  intensity,frequency= Hist(images[i])
  plt.subplot(1,len(images)+1,i+1)
  plt.stem(intensity,frequency)

"""####Histogram Equalization"""

img1=np.copy(img1)
r,nk= Hist(img1) # frequency of each intensity in the given image 
m,n=img1.shape #number of rows and columns in img1

#create a dataframe with intensity and its corresponding frequency
import pandas as pd
df=pd.DataFrame({"intensity":r,"frequency":nk})

pdf= nk/(m*n)     # Find probability of each pixel
pdf1= pdf.copy()
cdf= np.array(np.zeros(len(pdf)))
cdf[0]= pdf[0]
#Obtain CDF
for i in range(1,len(pdf)):
  cdf[i]= cdf[i-1]+pdf1[i]   #the last cdf val shd add to 1
  
sk= cdf*np.max(img1)
sk= sk.astype(int) #Rounding sk

#Assign columns pdf, cdf and sk to the dataframe
df['PDF']=pdf1
df['CDF']=cdf
df['Sk']=sk

#visualize the dataframe
df.tail(10)

imgEqu= np.zeros((m,n),dtype=int) #Create a matrix for equalized image

#Replace the pixel value in the original image by the pixel value sk obtained after equalization
for i in range(m):
  for j in range(n):
    temp= img1[i,j]
    imgEqu[i,j]= sk[temp]

imgEqu=imgEqu.astype('int')

#Plotting original and equalized image
plt.subplot(1,2,1)
plt.title("Original image")
plt.imshow(img1, cmap='gray', vmin=0, vmax=255)
plt.subplot(1,2,2)
plt.title("Equalized image")
plt.imshow(imgEqu, cmap='gray', vmin=0, vmax=255)

plt.figure(figsize= (25,5))
plt.subplot(1,3,1)
plt.title("Histogram of the original image")
plt.xlabel("intensity")
plt.ylabel("frquency of each intensity")
r,nk= Hist(img1)
plt.plot(r,nk)

plt.subplot(1,3,2)
plt.title("Histogram of the equalized image")
s,nq= Hist(imgEqu)
plt.plot(s,nq, "-r")
plt.xlabel("intensity")
plt.ylabel("frquency of each intensity")

plt.subplot(1,3,3)
plt.title("transformation function")
plt.plot(r,sk, "-g")
plt.xlabel("intensity in the original image")
plt.ylabel("intensity in the new image")

! jupyter nbconvert --to html /content/I078_SIP_Prac5.ipynb

"""###Conclusion:
Imported an image with 4 different intensities and performed histogram Equalization on the one with extreme intensity.

First created an histogram function to store the various pixels and each of their frequencies of any image. Plotted the histogram using these values. Then calculated the pdf(probability of the pixel) and cdf functions to generate equalized(i.e (L-1)*original pixel) pixels. Then plotted both the histogram to understand the difference. The original image had intensities to an extreme side while the equalized one had intensities spread throughout all the pixels.
"""