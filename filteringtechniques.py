# -*- coding: utf-8 -*-
"""FilteringTechniques.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p8bDk9MILFYxCjYDF68zUtr5Q0SR4QCp
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

img= cv2.imread("test.tif",0) # Read the image

img_fft= np.fft.fft2(img, s=None, axes=(-2, -1), norm=None) # Apply FFT on original image

img_fft= np.fft.fftshift(img_fft) #Shifting the origin. Equivalent to multiplying by (-1)^x+y

plt.imshow(img, cmap="gray")
plt.title("Ã–riginal image")

m,n= img_fft.shape #Obtaining size (rows and cols)of the image

#Creating ideal lpf and ideal hpf masks
lpf= img.copy()
hpf= img.copy()
#Take radii d0= 10, 30,60,160,460

d0= 60

for i in range(m):
  for j in range(n):
    d1= np.sqrt((i-m//2)**2 +(j-n//2)**2)
    if d1>d0:
      lpf[i,j]=0
      hpf[i,j]=1
    else:
      lpf[i,j]= 1
      hpf[i,j]=0

img_lpf= img_fft*lpf                       # multiply lpf mask with the fft image
img_lpf= np.fft.fftshift(img_lpf)          
img_new_lpf= np.real(np.fft.ifft2(img_lpf))  #computing inverse DFT

img_hpf= img_fft*hpf                       # multiply hpf mask with the fft image
img_hpf= np.fft.fftshift(img_hpf)          
img_new_hpf= np.real(np.fft.ifft2(img_hpf)) #computing inverse DFT

#Plot original, low pass filtered and high pass filtered image
plt.figure(figsize=(20,20))
plt.subplot(1,3,1)
plt.title("Original Image")
plt.imshow(img,cmap="gray")
plt.subplot(1,3,2)
plt.title("Low Pass Filtered Image for radius = " +str(d0))
plt.imshow(img_new_lpf,cmap="gray")
plt.subplot(1,3,3)
plt.title("High Pass filtered image for radius = " +str(d0))
plt.imshow(img_new_hpf,cmap="gray", vmin=0, vmax=255)

"""####Butterworth Filter"""

img=img.astype(np.float)
butter_lpf=img.copy()
butter_hpf=img.copy()
m,n= img_fft.shape 
d0=30
N=1      #filter order
for u in range(m):
  for v in range(n):
    d1=np.sqrt((u-m//2)**2 +(v-n//2)**2)
    butter_lpf[u,v]=1/(1+(d1/d0)**(2*N))
    butter_hpf[u,v]=1/(1+(d0/d1)**(2*N))

#Buterworth High Pass Filter
butter_hpf

#Buterworth Low Pass Filter
butter_lpf

img_lpfb= img_fft*butter_lpf 
img_lpfb= np.fft.fftshift(img_lpfb)
img_new_lpfb= np.real(np.fft.ifft2(img_lpfb)) # multiply lpf mask with the fft image

img_hpfb= img_fft*butter_hpf 
img_hpfb= np.fft.fftshift(img_hpfb)
img_new_hpfb= np.real(np.fft.ifft2(img_hpfb))  # multiply hpf mask with the fft image

plt.figure(figsize=(20,20))
plt.subplot(1,3,1)
plt.title("Original Image")
plt.imshow(img,cmap="gray")
plt.subplot(1,3,2)
plt.title("Low Pass Filtered Image for radius = " +str(d0))
plt.imshow(img_new_lpfb,cmap="gray")
plt.subplot(1,3,3)
plt.title("High Pass filtered image for radius = " +str(d0))
plt.imshow(img_new_hpfb,cmap="gray", vmin=0, vmax=255)

! jupyter nbconvert --to html I078_SIP_Prac6.ipynb

"""###Conclusion:
Applied filtering-ideal low and high pass filter on an image for various radius.
An ideal low pass filter elimantes all the frequencies above the cutoff(d0) frequency keeping the ones below unchanged. While,an ideal high ass filter blocks the frequencies below the cutoff freq.

Applied Butterworth filterng on the same image. A Butterworth high pass fiter sharpens the edges of the image while butterworth low pass filet smoothens the image,removing high freq noise.
Increasing the order of the filter decreases the quality of the image(patches are visible on the image)i.e ringing artifacts increases.

"""