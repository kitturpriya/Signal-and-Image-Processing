# -*- coding: utf-8 -*-
"""FourierTransform.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11U-kQejavmRlXTpGDIvL9jrcvjksBi6S
"""

import numpy as np

x=np.array([1,2,1,2]) #input sequence

#Obtaining fourier transform
X=np.fft.fft(x)  #applying fourier transform on x using inbuilt func fft from numpy
print(X)

#Obtaining Inverse Transform
Xi=np.fft.ifft(X) #applying inverse fourier transform to get the original(estimated)sequence.
print(Xi)

#matrix to obtain fourier transform

N=4
m=np.zeros((N,N),dtype=np.complex128)
for i in range(N):
   for j in range(N):
      E=(-2*np.pi*i*j)/N
      m[i,j]=complex(int(np.cos(E)),int(np.sin(E)))
m

#dot product of the transpose of the original seq with above matrix gives fourier transform of the seq.
xT=np.transpose(x)
fx=np.dot(m,xT)        
fx

#matrix to obtain inverse fourier transform
N=4
m1=np.zeros((N,N),dtype=np.complex128)
for i in range(N):
   for j in range(N):
      E=(2*np.pi*i*j)/N
      m1[i,j]=complex(int(np.cos(E)),int(np.sin(E)))
m1

#dot product of fourier transform with the matrix formed for inverse transform 
#divided by total no of input in the sequence yields inverse transform for the seq.
ifx=(np.dot(fx,m1))/N
ifx

"""##Conclusion:
Generated fourier and inverse fourier transform for a sequence using fft library functions from the numpy library.
Also,found out fourier and inverse fourier transforms without the help of built in functions. Generated matrix for the same(complex functions) and verified that the transforms are the same as generated by the built in functions.
"""